[%
@template
operation EClass testClass(interPrefix, interSufix, classPrefix, classSufix) {
    var container = self.getContainerReference().at(0);
    var containerClass = self.getContainerReference().at(1);
    var containment = self.getContainerReference().at(2);
    var containment_many = false;
    var contReferenceClass;
    var contReferenceInterface;
    var contReferenceVar;
	if (containment.isDefined()) {     // Container exists
	    containment_many = containment.isMany();
	    contReferenceInterface = containment.getRelationJavaInterfaceName(interPrefix, interSufix);
	    contReferenceClass = containment.getRelationJavaClassName(classPrefix, classSufix);
	    contReferenceVar = containerClass.name.firstToLowerCase();
	}
	out.setContentType("Java");%]
    
    public static class [%=self.getJavaClassName(classPrefix, classSufix)%]Tests extends EasyMockSupport {
    
        @Rule
        public EasyMockRule rule = new EasyMockRule(this);

[%  // Mock the refernce targets and create variables for the references
    for (er in self.getEAllReferences()) {%]
        /** Mock the target of the [%=er.name%] reference. */
        @Mock
        private [%=er.getEReferenceType().getJavaInterfaceName(interPrefix, interSufix)%] [%=er.name%]Mock1;
        
        /** Mock the target of the [%=er.name%] reference. */
        @Mock
        private [%=er.getEReferenceType().getJavaInterfaceName(interPrefix, interSufix)%] [%=er.name%]Mock2;
        
        [%if (er.getEOpposite().isDefined()) {
            var opp = er.getEOpposite();
            var oppClass = opp.getRelationJavaInterfaceName(interPrefix, interSufix);
            var oppVar = opp.getEContainingClass().name.firstToLowerCase();%]
        /** Allow the target mock to populate the reference */
        private [%=oppClass%] [%=oppVar%]1;
        
        /** Allow the target mock to populate the reference */
        private [%=oppClass%] [%=oppVar%]2;
        
        [%}%]
[%}%]
[%  // If the containment is not a Reference, we need to add a mock for it.
    if (containment.isDefined() and container.isUndefined()) {%]
        /** Mock the container. */
        @Mock
        private [%=containerClass.getJavaInterfaceName(interPrefix, interSufix)%] containerMock;
        
        /** Allow the container mock to populate the reference */
        private [%=contReferenceInterface%] [%=contReferenceVar%]1;
        
        /** Allow the container mock to populate the reference of second instance*/
        private [%=contReferenceInterface%] [%=contReferenceVar%]2;

[%}%]
        private [%=self.name%] classUnderTest;

[%  if (container.isDefined() or containment.isDefined()) {%]        
        @Test
        public void test[%=self.name%]Instantiation() throws Exception {
[%=self.initClassUnderTest(containerClass, containment, contReferenceClass, contReferenceVar, container, interPrefix, interSufix, classPrefix, classSufix)%]
[%  if (container.isDefined()) {%]
            assertThat(classUnderTest.[%=container.name%]().get(), is([%=container.name%]Mock1));
[%  }
    if (containment.isDefined()) {
        var containerVar;
        if (container.isUndefined()) {
            containerVar = "containerMock";
        }
        else {
            containerVar = container.name + "Mock1";
        }
        if (containment_many) {%]
            Queue<[%=containment.getEReferenceType().getJavaInterfaceName(interPrefix, interSufix)%]> values = [%=containerVar%].[%=containment.name%]().get();
            assertThat(values, hasItem(classUnderTest));
[%      } else {%]
            assertThat([%=containerVar%].[%=containment.name%]().get(), is(classUnderTest));
[%      }
    } %]
	    }
[%}%]	    
[%=out.startPreserve("Ignore" + self.name + "Attributes", true)%]	    
	    @Ignore
[%=out.stopPreserve()%]	    
	    @Test
        public void test[%=self.name%]Attributes() throws Exception {
[%=self.initClassUnderTest(containerClass, containment, contReferenceClass, contReferenceVar, container, interPrefix, interSufix, classPrefix, classSufix)%]
[%=out.startPreserve(self.name + "Attributes", true)%]
            // TODO Add test code for parameters (to hard to generate correct code for any type).                    
[%=out.stopPreserve()%]
        }

[%  if (container.isDefined()) {
        var mockContainer = container.name + "Mock";
        %]        
        @Test
        public void test[%=self.name%]Create[%=container.name.firstToUpperCase()%]ContainerReferenceConflict() throws Exception {
[%=self.initClassUnderTest(containerClass, containment, contReferenceClass, contReferenceVar, container, interPrefix, interSufix, classPrefix, classSufix)%]
[%      if (containment.isDefined()) {%]
            [%=contReferenceVar%]2 = new [%=contReferenceClass%]([%=mockContainer%]2);
            expect([%=mockContainer%]2.[%=containment.name%]()).andReturn([%=contReferenceVar%]2).anyTimes();
            replay([%=mockContainer%]2);
[%      }%]        
            boolean result = classUnderTest.[%=container.name%]().create([%=mockContainer%]2);
            assertFalse(result);
            
        }
        
        @Test
        public void test[%=self.name%]Destroy[%=container.name.firstToUpperCase()%]ContainerReference() throws Exception {
[%=self.initClassUnderTest(containerClass, containment, contReferenceClass, contReferenceVar, container, interPrefix, interSufix, classPrefix, classSufix)%]
            boolean result = classUnderTest.[%=container.name%]().destroy([%=mockContainer%]1);
            assertTrue(result);
        }
        
        @Test
        public void test[%=self.name%]DestroyAndCreate[%=container.name.firstToUpperCase()%]ContainerReference() throws Exception {
[%=self.initClassUnderTest(containerClass, containment, contReferenceClass, contReferenceVar, container, interPrefix, interSufix, classPrefix, classSufix)%]
[%      if (containment.isDefined()) {%]
            [%=contReferenceVar%]2 = new [%=contReferenceClass%]([%=mockContainer%]2);
            expect([%=mockContainer%]2.[%=containment.name%]()).andReturn([%=contReferenceVar%]2).anyTimes();
            replay([%=mockContainer%]2);
[%      }%]  
            boolean result = classUnderTest.[%=container.name%]().destroy([%=mockContainer%]1);
            assertTrue(result);
            result = classUnderTest.[%=container.name%]().create([%=mockContainer%]2);
            assertTrue(result);
            result = classUnderTest.[%=container.name%]().create([%=mockContainer%]2);
            assertFalse(result);
            result = classUnderTest.[%=container.name%]().create([%=mockContainer%]1);
            assertFalse(result);
        }
        
[%  }%]
[%  for (er in self.getEAllReferences().excluding(container)) {
        //var erTargetMock = er.getEReferenceType().name.firstToLowerCase() + "Mock";
        var erTargetMock = er.name + "Mock";
        var opp;
        var oppClass;
        var oppVar;
        if (er.getEOpposite().isDefined()) {
            opp = er.getEOpposite();
            oppClass = opp.getRelationJavaClassName(classPrefix, classSufix);
            oppVar = opp.getEContainingClass().name.firstToLowerCase();
        }
        var mockTarget = erTargetMock + "1";
        if (er.isRequired() and not er.isMany()) {
            mockTarget = "_" + er.name;
        }
        %]
        @Test
        public void test[%=self.name%]Create[%=er.name.firstToUpperCase()%]Reference() throws Exception {
[%=self.initClassUnderTest(containerClass, containment, contReferenceClass, contReferenceVar, container, interPrefix, interSufix, classPrefix, classSufix)%]
[%      if (er.getEOpposite().isDefined()) {%]
            [%=oppVar%]1 = new [%=oppClass%]([%=erTargetMock%]1);
            expect([%=erTargetMock%]1.[%=opp.name%]()).andReturn([%=oppVar%]1).anyTimes();
            replay([%=erTargetMock%]1);
[%      }%]
[%      if (er.getEOpposite().isDefined()) {%]
            [%=oppVar%]2 = new [%=oppClass%]([%=erTargetMock%]2);
            expect([%=erTargetMock%]2.[%=opp.name%]()).andReturn([%=oppVar%]2).anyTimes();
            replay([%=erTargetMock%]2);
[%      }%]
            boolean result;
[%      if (not (er.isRequired() and not er.isMany())) {%]
            result = classUnderTest.[%=er.name%]().create([%=mockTarget%]);
            assertTrue(result);
[%      }%]
            result = classUnderTest.[%=er.name%]().create([%=erTargetMock%]2);
[%      if (er.isMany()){%]
            assertTrue(result);
[%      } else {%]
            assertFalse(result);
[%      }%]
            result = classUnderTest.[%=er.name%]().create([%=mockTarget%]);
            assertFalse(result);
            // Create a second one
[%=self.newInitClassUnderTest(2, containerClass, containment, contReferenceClass, contReferenceVar, container, interPrefix, interSufix, classPrefix, classSufix)%]
            assertThat(classUnderTest[%=2%], is(notNullValue()));
        }
        
        @Test
        public void test[%=self.name%]Destroy[%=er.name.firstToUpperCase()%]Reference() throws Exception {
[%=self.initClassUnderTest(containerClass, containment, contReferenceClass, contReferenceVar, container, interPrefix, interSufix, classPrefix, classSufix)%]
[%      if (er.getEOpposite().isDefined()) {%]
            [%=oppVar%]1 = new [%=oppClass%]([%=erTargetMock%]1);
            expect([%=erTargetMock%]1.[%=opp.name%]()).andReturn([%=oppVar%]1).anyTimes();
            replay([%=erTargetMock%]1);
[%      }%]
[%      if (not (er.isRequired() and not er.isMany())) {%]
            classUnderTest.[%=er.name%]().create([%=mockTarget%]);
[%      }%]
[%  for (rf in self.getRequiredFeatures()) {
        if (not rf.isMany() and rf.getEOpposite().isDefined()) {
            var opp = rf.getEOpposite();
            var oppVar = opp.getEContainingClass().name.firstToLowerCase();%]
            // Opposite for [%=rf.name%]
            //reset([%=oppVar%]);
            //expect([%=oppVar%].get()).andReturn(classUnderTest).anyTimes();
            //replay([%=oppVar%]);
[%      }%]        
[%  }%]
            boolean result = classUnderTest.[%=er.name%]().destroy([%=mockTarget%]);
            assertTrue(result);
[%  if (er.isMany()) {%]
            assertThat(classUnderTest.[%=er.name%]().get(), not(hasItem([%=erTargetMock%]1)));
[%  } else {%]
            assertThat(classUnderTest.[%=er.name%]().get(), is(nullValue()));
[%  }%]
[%      if (er.getEOpposite().isDefined()) {%]
            [%=oppVar%]2 = new [%=oppClass%]([%=erTargetMock%]2);
            expect([%=erTargetMock%]2.[%=opp.name%]()).andReturn([%=oppVar%]2).anyTimes();
            replay([%=erTargetMock%]2);
[%      }%]
            result = classUnderTest.[%=er.name%]().destroy([%=erTargetMock%]2);
            assertFalse(result);
        }
[%}%]
    }
[%}
@template
operation EClass initClassUnderTest(containerClass, containment, contReferenceClass,
                                    contReferenceVar, container, interPrefix, interSufix, classPrefix, classSufix) {
    var mockContainer; 
    if (containerClass.isDefined()) {
        if (container.isUndefined()) {
            mockContainer = "containerMock";
        } else {
            //mockContainer = containerClass.name.firstToLowerCase() + "Mock1";
            mockContainer = container.name + "Mock1";
        }%]
            [%=contReferenceVar%]1 = new [%=contReferenceClass%]([%=mockContainer%]);
            expect([%=mockContainer%].[%=containment.name%]()).andReturn([%=contReferenceVar%]1).anyTimes();
            replay([%=mockContainer%]);
[%  }%]
[%  for (rf in self.getRequiredFeatures()) {%]
            [%=rf.getEReferenceType().getJavaInterfaceName(interPrefix, interSufix)%] _[%=rf.name%] = mock([%=rf.getEReferenceType().getJavaInterfaceName(interPrefix, interSufix)%].class);
[%      if (not rf.isMany() and rf.getEOpposite().isDefined()) {
            var opp = rf.getEOpposite();
            var oppClass = opp.getRelationJavaInterfaceName(interPrefix, interSufix);
            var oppVar = opp.getEContainingClass().name.firstToLowerCase();%]
            [%=oppClass%] [%=oppVar%] = niceMock([%=oppClass%].class);
            expect(_[%=rf.name%].[%=rf.getEOpposite().name%]()).andReturn([%=oppVar%]).anyTimes();
            replay(_[%=rf.name%]);
            expect([%=oppVar%].get()).andReturn(null).anyTimes();
            replay([%=oppVar%]);
[%      }%]        
[%  }%]
[%  
    var params = self.getIndexAttributes().collect(a | a.getInitValue(1));
    // We need a mock for the Required EReferences used in the constructor
    params.addAll(self.getRequiredFeatures().collect(a | "_" + a.name));
    if (containerClass.isDefined()) {
        params.add(mockContainer);
    }
    if (params.isEmpty()) {
        params = "";
    }
    else {
        params = params.concat(", ");
    }%]
            [%=out.startPreserve(self.name + "Init", true)%]
            // Default init parameters can be modified
            classUnderTest = new [%=self.getJavaClassName(classPrefix, classSufix)%]([%=params%]);                    
            [%=out.stopPreserve()%]     
[%}

@template
operation EClass newInitClassUnderTest(index, containerClass, containment, contReferenceClass,
                                    contReferenceVar, container, interPrefix, interSufix, classPrefix, classSufix) {
    var mockContainer;
    if (containerClass.isDefined()) {
        if (container.isUndefined()) {
            mockContainer = "containerMock";
        } else {
            //mockContainer = containerClass.name.firstToLowerCase() + "Mock1";
            mockContainer = container.name + "Mock1";
        }%]
        replay([%=mockContainer%]);
[%  }%]
[%  for (rf in self.getRequiredFeatures()) {%]
            [%=rf.getEReferenceType().getJavaInterfaceName(interPrefix, interSufix)%] _[%=rf.name%][%=index%] = mock([%=rf.getEReferenceType().getJavaInterfaceName(interPrefix, interSufix)%].class);
[%      if (not rf.isMany() and rf.getEOpposite().isDefined()) {
            var opp = rf.getEOpposite();
            var oppClass = opp.getRelationJavaInterfaceName(interPrefix, interSufix);
            var oppVar = opp.getEContainingClass().name.firstToLowerCase() + index;%]
            [%=oppClass%] [%=oppVar%] = niceMock([%=oppClass%].class);
            expect(_[%=rf.name%][%=index%].[%=rf.getEOpposite().name%]()).andReturn([%=oppVar%]).anyTimes();
            replay(_[%=rf.name%][%=index%]);
            expect([%=oppVar%].get()).andReturn(null).anyTimes();
            replay([%=oppVar%]);
[%      }%]             
[%}%]
[% 
    var params = self.getIndexAttributes().collect(a | a.getInitValue(index));
    // We need a mock for the Required EReferences used in the constructor
    params.addAll(self.getRequiredFeatures().collect(a | "_" + a.name + index));
    if (containerClass.isDefined()) {
        params.add(mockContainer);
    }
    if (params.isEmpty()) {
        params = "";
    }
    else {
        params = params.concat(", ");
    }%]
            [%=self.getJavaClassName(interPrefix, interSufix)%] classUnderTest[%=index%] = new [%=self.getJavaClassName(classPrefix, classSufix)%]([%=params%]);
[%}

operation EAttribute getInitValue(index) : Any {
    switch(self.getEAttributeType().getName()) {
        case "EString": return '"' + self.name + index + '"';
        case "EIntegerObject": return 0 + index;
        case "EBoolean": return false and (index.mod(2) == 0);
        case "AnyURI": return '"url://path/in/model/to/' + self.name + "/" + index + '"';
        default: self.getEAttributeType().getName(); return null;
    }
    
}
%]