[%
/*******************************************************************************
 * Copyright (c) 2017 The University of York.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Horacio Hoyos Rodriguez - initial API and implementation
 ******************************************************************************/
import "Ecore2JavaTemplates.egl";  

/**
 * Generation of Java Interface from an EReference.
 */
var targetType = er.getEReferenceType().name;
%]
 /*******************************************************************************
 * This file was automatically generated on: [%=today%].
 * Only modify protected regions indicated by "<!-- -->"
 *
 * Copyright (c) 2017 The University of York.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 ******************************************************************************/
package [%=qp%].trace;

[%if (er.isMany()) {%]
import java.util.Queue;
[%}%]

public interface [%=featureType%] {
    
    /**
     * Get the value(s) for the reference
     */
[%if (er.isMany()) {%]
    Queue<[%=targetType%]> get();
[%} else {%]
    [%=targetType%] get();
[%}%]

    /**
	 * Set a new value for the reference. Although public, this method should be only accessed by
	 * classes in the same package or extrange behavoir can be observed.
	 */
    void set([%=targetType%] target);

    /**
     * Remove a value for the reference. Although public, this method should be only accessed by
     * classes in the same package or extrange behavoir can be observed.
     */
    void remove([%=targetType%] target);
    
    /**
     * Determines if there is a conflict with a possible target.
     * Returns true if the opposite reference is already set, or if this refernce is single-valued
     * and is already set.
     */
    boolean conflict([%=targetType%] target);
    
    /**
     * Retruns true if the target is already related via this reference.
     */
    boolean related([%=targetType%] target);
    
    /**
     * Create a reference to the target element. Returns true if the relation was created.
     * Single-valued references can only be set if not set.
     * Unique Multi-valued references can only be set if not set before.
     * If the reference has an opposite, the refletive relation
     * is also created.
     */
    boolean create([%=targetType%] target);
    
    /**
     * Destroy a reference to the target element. Returns true, if the reference existed
     * and was properly destroyed. If the reference has an opposite, the refletive relation
     * is also destroyed.
     */    
    boolean destroy([%=targetType%] target);
    

}