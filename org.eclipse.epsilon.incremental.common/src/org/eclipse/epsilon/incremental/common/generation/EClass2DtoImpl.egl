[%
/*******************************************************************************
 * Copyright (c) 2017 The University of York.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Horacio Hoyos Rodriguez - initial API and implementation
 ******************************************************************************/
/**
 * A template to generate an implementation of an EClass that can be used as a DTO.
 */
import "Ecore2JavaTemplates.egl";
 %]
 /*******************************************************************************
 * This file was automatically generated on: [%=today%].
 * Only modify protected regions indicated by "<!-- -->"
 *
 * Copyright (c) 2017 The University of York.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 ******************************************************************************/
package [%=qp%].trace.impl;

import [%=qp%].trace.[%=ec.getJavaInterfaceName(interPrefix, interSufix)%];
import java.util.NoSuchElementException;

import org.eclipse.epsilon.eol.incremental.EolIncrementalExecutionException;
import org.eclipse.epsilon.eol.incremental.trace.impl.TraceModelDuplicateRelation;
[%
for (imp in ec.getRequriedImports(qp+".trace", interPrefix, interSufix, classPrefix, classSufix, true, true)) {%]
import [%=imp%];
[%}%]

/**
 * Implementation of [%=ec.getJavaInterfaceName(interPrefix, interSufix)%]. 
 */
public class [%=ec.getJavaClassName(classPrefix, classSufix)%] implements [%=ec.getJavaInterfaceName(interPrefix, interSufix)%] {

[%  // Craete a field for each attribute
for (ea in ec.getEAllAttributes()) {
    var multi = "List";
    if (ea.isOrdered()) { multi = "Set"; }%]
    /** The [%=ea.name%] */
    private [%=ea.getGetterReturnType(multi)%] [%=ea.name%];

[%}%]
[%  // Craete a field for each reference
for (er in ec.getEAllReferences()) {%]
    /** The [%=er.name%] relation */
    private final [%=er.getRelationJavaInterfaceName(interPrefix, interSufix)%] [%=er.name%];

[%}%]
    /**
     * Instantiates a new [%=ec.getJavaClassName(classPrefix, classSufix)%]. The [%=ec.getJavaClassName(classPrefix, classSufix)%] is uniquely identified by its
     * container and any attributes identified as indexes.
     */    
    public [%=ec.getJavaClassName(classPrefix, classSufix)%]([%=ec.getConstructorParameters(true, interPrefix, interSufix)%]) throws TraceModelDuplicateRelation {
[%for (index in ec.getIndexAttributes()) {%]
        this.[%=index.name%] = [%=index.name%];
[%}%]
[%for (er in ec.getEAllReferences()) {%]
        this.[%=er.name%] = new [%=er.getRelationJavaClassName(classPrefix, classSufix)%](this);
[%  if ((er <> ec.getContainerReference().at(0)) and er.isRequired() and not er.isMany()) {%]
        this.[%=er.name%].create([%=er.name%]);
[%  }%]
[%}%]
[%var container = ec.getContainerReference().at(2);
var containment = ec.getContainerReference().at(0);
if (container.isDefined()) {%]
        if (!container.[%=container.name%]().create(this)) {
            throw new TraceModelDuplicateRelation();
        };
[%} else if (containment.isDefined()) {%]
        if (!container.[%=ec.getContainerReference().at(0).name%]().create(this){
            throw new TraceModelDuplicateRelation();
        };
[%}%]
    }
    
[%for (ea in ec.getEAllAttributes()) {
    var multi = "List";
    if (ea.isOrdered()) {
        multi = "Set";
    }%]
    @Override
    public [%=ea.makeGetterSignature(multi)%] {
        return [%=ea.name%];
    }
    
[%  if (not ea.isMany()) {%]    
    @Override
    public [%=ea.makeSetterSignature(multi)%] {
        this.[%=ea.name%] = value;
    }   
     
[%  }
}%]
[%for (er in ec.getEAllReferences()) {%]
    @Override
    public [%=er.getRelationJavaInterfaceName(interPrefix, interSufix)%] [%=er.name%]() {
        return [%=er.name%];
    }

[%
}%]
[%/* Factory Methods
 * If the EReferenceType is abstract, we add factory methods for each of the subclasses of the
 * EReferenceType. We only look for all classes as we are implementing the methods.
 */
for (er in ec.getEAllReferences().select(er | er.isContainment())) {
    if (not er.getEReferenceType().isAbstract()) {%]
    [%=er.getEReferenceType().factoryMethod(er, false, interPrefix, interSufix, classPrefix, classSufix)%]
[%  } else {
        var subClasses = er.getEReferenceType().getEAllSubclasses();
        for (sc in subClasses.select(sc | not sc.isAbstract())) {%]
    [%=sc.factoryMethod(er, true, interPrefix, interSufix, classPrefix, classSufix)%]
            
[%      }%]
[%  }%]
                  
[%}%]
    @Override
    public boolean sameIdentityAs(final [%=ec.getJavaInterfaceName(interPrefix, interSufix)%] other) {
        if (other == null) {
            return false;
        }
[%for (index in ec.getIndexAttributes()) {%]
        if (get[%=index.name.firstToUpperCase()%]() == null) {
            if (other.get[%=index.name.firstToUpperCase()%]() != null)
                return false;
        } else if (!get[%=index.name.firstToUpperCase()%]().equals(other.get[%=index.name.firstToUpperCase()%]()))
            return false;
[%}%]
        return true;
    }

    @Override
    public boolean equals(final Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (!(obj instanceof [%=ec.getJavaClassName(classPrefix, classSufix)%]))
            return false;
        [%=ec.getJavaClassName(classPrefix, classSufix)%] other = ([%=ec.getJavaClassName(classPrefix, classSufix)%]) obj;
        if (!sameIdentityAs(other))
            return false;
[%
container = ec.getContainerReference().at(0);
if (container.isDefined()) {%]
        if ([%=container.name%].get() == null) {
            if (other.[%=container.name%].get() != null)
                return false;
        } else if (![%=container.name%].get().equals(other.[%=container.name%].get()))
            return false;
[%}%]
        return true; 
  }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
[%if (container.isDefined()) {%]
        result = prime * result + (([%=container.name%].get() == null) ? 0 : [%=container.name%].get().hashCode());
[%}%]
[%for (index in ec.getIndexAttributes()) {%]
        result = prime * result + (([%=index.name%] == null) ? 0 : [%=index.name%].hashCode());
[%}%]
        return result;
    }

}
[%
@template
operation EClass factoryMethod(ref : EReference, subClass : Boolean, interPrefix:String,
                               interSufix:String, classPrefix:String, classSufix:String) {
    var instanceName = self.name.firstToLowerCase();
    var params = self.getEAttributeParameters().includingAll(self.getRequiredFeatureParameters(interPrefix, interSufix));
    var vars = self.getIndexAttributes().includingAll(self.getRequiredFeatures()).collect(a | a.name);
    var container = self.getContainerReference().at(2);
    var containment = self.getContainerReference().at(0);
    if (container.isDefined()) {
        vars.add("this");
    }%]
@Override
public [%=self.getJavaInterfaceName(interPrefix, interSufix)%] create[%=self.name%]([%=params.concat(", ")%]) throws EolIncrementalExecutionException {
    [%=self.getJavaInterfaceName(interPrefix, interSufix)%] [%=instanceName%] = null;
    try {
        [%=instanceName%] = new [%=self.getJavaClassName(classPrefix, classSufix)%]([%=vars.concat(", ")%]);
[% if (containment.isDefined()) {%]        
        this.[%=container.name%]().create([%=instanceName%]);
[%  }%]
    } catch (TraceModelDuplicateRelation e) {
        // Pass
    } finally {
	    if ([%=instanceName%] != null) {
	        return [%=instanceName%];
	    }
[%  if (ref.isMany()) {%]
        try {
            [%=instanceName%] = this.[%=ref.name%].get().stream()
[%// Need to cast for subclasses
        if (subClass) {%]
                .map([%=self.name%].class::cast)
[%      }%]
[%      for (param in self.getIndexAttributes()) {%]
                .filter(item -> item.get[%=param.name.firstToUpperCase()%]().equals([%=param.name%]))
[%      }%]
[%      for (param in self.getRequiredFeatures()) {%]
                .filter(item -> item.[%=param.name%]().get().equals([%=param.name%]))
[%      }%]
                .findFirst()
                .get();
        } catch (NoSuchElementException ex) {
            throw new EolIncrementalExecutionException("Error creating trace model element. Requested [%=self.name%] was "
                    + "duplicate but previous one was not found.");
        }
[%  } else {%]
        [%=instanceName%] = [%if (subClass) {%]([%=self.name%]) [%}%]this.[%=ref.name%].get();
        if ([%=instanceName%]  == null) {
            throw new EolIncrementalExecutionException("Error creating trace model element. Requested [%=self.name%] was "
                    + "duplicate but previous one was not found.");
        }
[%  }%]
    }
    return [%=self.name.firstToLowerCase()%];
}      
[%}
%]