
operation EClass getJavaTypeName(typePrefix, typeSufix) {
	
	return typePrefix + self.getName() + typeSufix;
}

operation EReference getJavaTypeName(typePrefix, typeSufix) {
	
	return typePrefix + self.getName().firstToUpperCase() + typeSufix;
}

// Get all EDataTypes that are not java.lang.* and all EClasses that are not
// in the same pacakge. Assumes other packages are generated in the same
// base package
operation EClass getRequriedImports(basePackage:String, typePrefix:String, typeSufix:String) : Sequence {
    return self.getRequriedImports(basePackage, typePrefix, typeSufix, false);
}
/**
 * If isImpl is True, it will also add concrete implementations of the collections imports
 */
operation EClass getRequriedImports(basePackage:String, typePrefix:String, typeSufix:String, isImpl:Boolean) : Sequence {
    return self.getRequriedImports(basePackage, typePrefix, typeSufix, false, false);
}

operation EClass getRequriedImports(basePackage:String, typePrefix:String, typeSufix:String,
                                    isImpl:Boolean, flatten:Boolean) : Sequence {
    var imports : Set;
    var eas;
    var ers;
    if (not flatten) {
        eas = self.getEAttributes();
        ers = self.getEReferences();
    }
    else {
        //self.name.println("EAllFeatures ");
        eas = self.getEAllAttributes();
        ers = self.getEAllReferences();
    }
    for (ea in eas) {
        imports.addAll(ea.getImports(isImpl));
    }
    for (er in ers) {
        var type = er.getEReferenceType();
        var erqp = type.getCorrectPackage(basePackage, self);
        //var pack = er.getEReferenceType().getEPackage().name;
        //var erqp = basePackage.replace("." + self.getEPackage().name + ".", "." + pack + ".");
        if (er.isContainment()) {
            if (type.isAbstract()) {
                var subClasses = er.getEReferenceType().getEAllSubclasses();
		        for (sc in subClasses) {
		            imports.add(erqp + "." + sc.getJavaTypeName(typePrefix, typeSufix));
	                if (isImpl) {
	                    imports.add(erqp + ".impl." + sc.getJavaTypeName(typePrefix, "Impl"));
	                }
	                // Add imports for the constructor 
	                for (ea in sc.getIndexAttributes()) {
	                   imports.addAll(ea.getImports(isImpl));
	                }
	                for (er in sc.getRequiredFeatures()) {
	                   var rferqp = er.getEReferenceType().getCorrectPackage(basePackage, self);
	                   imports.add(rferqp + "." + er.getEReferenceType().getJavaTypeName(typePrefix, typeSufix));
	                }
		        }
            }
            else {
                imports.add(erqp + "." + type.getJavaTypeName(typePrefix, typeSufix));
                if (isImpl) {
                    imports.add(erqp + ".impl." + type.getJavaTypeName(typePrefix, "Impl"));
                }
            }
        }
        else {
            imports.add(erqp + "." + type.getJavaTypeName(typePrefix, typeSufix));
        }
        if (flatten) {
            if (er.getEContainingClass().getEPackage() <> self.getEPackage()) {
                imports.add(erqp + "." + er.getEContainingClass().name + "Has" + er.name.firstToUpperCase());
            }
            else {
                imports.add(basePackage + "." + er.getEContainingClass().name + "Has" + er.name.firstToUpperCase());
            }
            
        }
        if (isImpl) {
            //er.name.println("Adding impl import ");
            if (er.getEContainingClass().getEPackage() <> self.getEPackage()) {
                imports.add(erqp + ".impl." + er.getEContainingClass().name + "Has" + er.name.firstToUpperCase() + "Impl");
            }
            else {
                imports.add(basePackage + ".impl." + er.getEContainingClass().name + "Has" + er.name.firstToUpperCase() + "Impl");
            }
        }
        //if (type.getEPackage() <> self.getEPackage()) {
        //    imports.add(basePackage + "." + type.getJavaTypeName(typePrefix, typeSufix));
        //}
        //imports.addAll(er.getRequiredImports(isImpl));
    }
    if (isImpl) {
		var containerType = self.getContainerReference().at(1);
		if (containerType.isDefined()) {
		    var fullpath = basePackage + ".";
		    if (containerType.getEPackage() <> self.getEPackage()) {
		        fullpath = basePackage.replace("." + self.getEPackage().name + ".", "." + containerType.getEPackage().name + ".");
		    }
		    imports.add(fullpath + containerType.getJavaTypeName(typePrefix, typeSufix));
		}
    }
    for (ec in self.getESuperTypes().select(st | not (isImpl and st.isAbstract()))) {
        if (ec.getEPackage() <> self.getEPackage()) {
            imports.add("org.eclipse.epsilon." + ec.getEPackage().name + ".incremental.trace." + ec.getJavaTypeName(typePrefix, typeSufix));
        }
    }
    return imports.sortBy(im | im);
}

operation EClass getCorrectPackage(basePackage, baseClass : EClass) : String {
    var pack = self.getEPackage().name;
    var erqp = basePackage.replace("." + baseClass.getEPackage().name + ".", "." + pack + ".");
    return erqp;
}

// Return the EReference and Type of the container reference
@cached
operation EClass getContainerReference() : Sequence {
    var container = self.getEAllReferences().selectOne(er | er.isContainer());
    var type;
    var opposite;
    if (container.isUndefined()) {
        //Containment might not have an opposite, we assume elements can only be contained by one other relation
        opposite = EReference.all.selectOne(er | er.isContainment() and (er.getEReferenceType() == self));
        if (opposite.isDefined()) {
            type = opposite.getEContainingClass();
        }
    }
    else {
        opposite = container.getEOpposite();
        type = container.getEReferenceType();
    }
    return Sequence{container, type, opposite};
}

operation EStructuralFeature getRequiredImports(isImpl:Boolean) : Set {
    var result = new Set();
    if (self.isMany()) {
        if (self.isOrdered) {
            result.add("java.util.List");
            if (isImpl) {
                result.add("java.util.ArrayList");                
            }
        }
        else {
            result.add("java.util.Set");
            if (isImpl) {
                result.add("java.util.HashSet");                
            }
        }
    }
    return result;
}

operation EAttribute getImports(isImpl : Boolean) : Set {
    var result = new Set();
    var dataTypeName = self.getEAttributeType().getInstanceTypeName();
    if (not dataTypeName.startsWith("java.lang.") and ".".isSubstringOf(dataTypeName)) {
        result.add(dataTypeName);
    }
    result.addAll(self.getRequiredImports(isImpl));
    return result;
}

/**
 * Get a list of <Type name> strings for each of the EAttributes of the class.
 */
operation EClass getEAttributeParameters() : Sequence {
    var results : Sequence = new Sequence();
    var attr =self.getIndexAttributes(); 
    for (a in attr) {
        var type = a.getGetterReturnType("");
        var name = a.getName();
        results.add(type + " " + name);
    }
    return results;
}

operation EClass getRequiredFeatureParameters() {
    var results : Sequence = new Sequence();
    for (er in self.getRequiredFeatures()) {
        results.add(er.getEReferenceType().name + " " + er.name);
    }
    return results;
}

operation EClass getRequiredFeatures() {
    return self.getEAllReferences().select(er | er.isRequired() and not er.isMany()).excluding(self.getContainerReference().at(0));
}

/**
 * Get the select methods information. If available, returns a Bag containing two Sequences. The 
 * first is the list of types in the path, the second is the list of attributes/references to match.
 */
@cached 
operation EClass getSelect() : Sequence {
    var annot = self.getEAnnotation("https://eclipse.org/epsilon/incremental/OrientDbSelect");
    var result : Bag;
    if (annot.isUndefined()) {
        return result;
    }
    result.add(annot.getReferences());
    var details = annot.getDetails();
    if (details.containsKey('match')) {
        result.add(details.get('match').split(','));
    }
    return result;
}

/**
 * Get the index information. If available, returns a Sequence containing the EAttribute static 
 * identifier (same used when creating the vertex class) and the index type.
 */
@cached 
operation EClass getIndex() : Sequence {
	var annot = self.findIndexAnnotation();
    if (annot.isUndefined()) {
        return null;
    }
    var details = annot.getDetails();
    if (details.containsKey('type')) {
        var attr = annot.getReferences().first().getName().splitCamelCase("_").toUpperCase();
        var type = details.get('type');
        var res : Sequence();
        res.add(attr);
        res.add(type);
        return res;
    }
    return null;
}
@cached
operation EClass getIndexAttributes() : Sequence {
    var result : Sequence();
    var annot = self.findIndexAnnotation();
    if (annot.isDefined()) {
        result.addAll(annot.getReferences());
    }
    return result;
}

// The annotation might be in the class or any of its super classes
operation EClass findIndexAnnotation() : EAnnotation {
    var annot = self.getEAnnotation("https://eclipse.org/epsilon/incremental/OrientDbIndex");
    if (annot.isUndefined()) {
        annot = self.getEAllSuperTypes()
            .collect(st | st.getEAnnotation("https://eclipse.org/epsilon/incremental/OrientDbIndex"))
            .selectOne(an | an.isDefined());
    }
    return annot;
}

@cached
operation EClass getEAllSubclasses() {
    return EClass.all().select(ec | ec.getEAllSuperTypes().includes(self));
}

@cached
operation EDataType getJavaClassName() {
    return self.getInstanceTypeName().split("\\.").last();
}

@cahced
operation EReference isEdge() : Boolean {
    var annot = self.getEAnnotation("https://eclipse.org/epsilon/incremental/Graph");
    if (annot.isUndefined()) {
        return false;
    }
    var details = annot.getDetails();
    if (details.containsKey('edge')) {
        var isEdge = details.get('edge');
        return isEdge == 'true';
    }
    return false;
}

operation String splitCamelCase() : String {
	return self.splitCamelCase(" ");
}

operation String splitCamelCase(char : String) : String {
	var sp = self.split("(?<=[a-z])(?=[A-Z])|(?<=[A-Z])(?=[A-Z][a-z])");
	return sp.concat(char).firstToUpperCase();
}